var documenterSearchIndex = {"docs":
[{"location":"reference/foreach/#foreach()","page":"foreach()","title":"foreach()","text":"","category":"section"},{"location":"reference/foreach/","page":"foreach()","title":"foreach()","text":"tforeach","category":"page"},{"location":"reference/foreach/#ThreadedIterables.tforeach","page":"foreach()","title":"ThreadedIterables.tforeach","text":"tforeach(f::Function, c::AbstractArray)::Nothing\n\nMulti-threaded version of foreach(f, c).\n\n\n\n\n\n","category":"function"},{"location":"reference/mapreduce/#mapreduce()","page":"mapreduce()","title":"mapreduce()","text":"","category":"section"},{"location":"reference/mapreduce/","page":"mapreduce()","title":"mapreduce()","text":"For this function, there are three versions available - tmapreduce, which parallelises only the mapping part (only function f), maptreduce, which parallelises only the reduction part (only function op) and tmaptreduce, which parallelises both.","category":"page"},{"location":"reference/mapreduce/","page":"mapreduce()","title":"mapreduce()","text":"tmapreduce\nmaptreduce\ntmaptreduce","category":"page"},{"location":"reference/mapreduce/#ThreadedIterables.tmapreduce","page":"mapreduce()","title":"ThreadedIterables.tmapreduce","text":"tmapreduce(f::Function, op::Function, itr::AbstractArray)\n\nMulti-threaded version of mapreduce(f, op, itr). Only the mapping part is parallelised.\n\n\n\n\n\n","category":"function"},{"location":"reference/mapreduce/#ThreadedIterables.maptreduce","page":"mapreduce()","title":"ThreadedIterables.maptreduce","text":"maptreduce(f::Function, op::Function, itr::AbstractArray)\n\nMulti-threaded version of mapreduce(f, op, itr). Only the reduction part is parallelised. Note that function op must not change type!\n\n\n\n\n\n","category":"function"},{"location":"reference/mapreduce/#ThreadedIterables.tmaptreduce","page":"mapreduce()","title":"ThreadedIterables.tmaptreduce","text":"tmaptreduce(f::Function, op::Function, itr::AbstractArray)\n\nMulti-threaded version of mapreduce(f, op, itr). Both the mapping and the reduction part is parallelised. Note that function op must not change type!\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/#Using-a-macro","page":"Getting started","title":"Using a macro","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The simplest way to use the package is the @threaded macro, which converts the expression following it into a multi-threaded one.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Example:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> using ThreadedIterables\n\njulia> a = rand(1:10, 4)\n4-element Array{Int64,1}:\n  4\n  7\n 10\n  7\n\njulia>@threaded map(x -> 2x, a)\n4-element Array{Int64,1}:\n  8\n 14\n 20\n 14","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The macro converts all supported functions in the expression, so in the following example, both of the maps will be multi-threaded:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> using ThreadedIterables\n\njulia> a = rand(1:10, 4)\n4-element Array{Int64,1}:\n 1\n 5\n 2\n 3\n\njulia> @threaded map(x -> x + 1, map(x -> 2x, a))\n4-element Array{Int64,1}:\n  3\n 11\n  5\n  7","category":"page"},{"location":"getting_started/#Using-a-function","page":"Getting started","title":"Using a function","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"If you want a more fine-grained control over which functions get converted, you can use the multi-threaded functions from this package manually. For a list of all the supported functions, see the reference.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"In this example, only the outer map will be multi-threaded:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"julia> using ThreadedIterables\n\njulia> a = rand(1:10, 4)\n4-element Array{Int64,1}:\n 1\n 5\n 2\n 3\n\njulia> tmap(x -> x + 1, map(x -> 2x, a))\n4-element Array{Int64,1}:\n  3\n 11\n  5\n  7","category":"page"},{"location":"reference/map/#map()","page":"map()","title":"map()","text":"","category":"section"},{"location":"reference/map/","page":"map()","title":"map()","text":"tmap\ntmap!","category":"page"},{"location":"reference/map/#ThreadedIterables.tmap!","page":"map()","title":"ThreadedIterables.tmap!","text":"tmap!(f::Function, destination::AbstractArray, collection::AbstractArray)::Nothing\n\nMulti-threaded version of map!(f, destination, collection).\n\n\n\n\n\n","category":"function"},{"location":"reference/mapfoldr/#mapfoldr()","page":"mapfoldr()","title":"mapfoldr()","text":"","category":"section"},{"location":"reference/mapfoldr/","page":"mapfoldr()","title":"mapfoldr()","text":"tmapfoldr","category":"page"},{"location":"reference/mapfoldr/#ThreadedIterables.tmapfoldr","page":"mapfoldr()","title":"ThreadedIterables.tmapfoldr","text":"tmapfoldr(f::Function, op::Function, itr::AbstractArray)::AbstractArray\n\nMulti-threaded version of mapfoldr(f, op, itr). Only the mapping part is parallelised.\n\n\n\n\n\n","category":"function"},{"location":"reference/reduce/#reduce()","page":"reduce()","title":"reduce()","text":"","category":"section"},{"location":"reference/reduce/","page":"reduce()","title":"reduce()","text":"treduce","category":"page"},{"location":"reference/reduce/#ThreadedIterables.treduce","page":"reduce()","title":"ThreadedIterables.treduce","text":"treduce(op::Function, itr::AbstractArray)\n\nMulti-threaded version of reduce(op, itr). Note that function op must not change type!\n\n\n\n\n\n","category":"function"},{"location":"#ThreadedIterables.jl-Documentation","page":"Home","title":"ThreadedIterables.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements Multi-threaded variants of the mapping functions (currently foreach, map, reduce, mapreduce, mapfoldl and mapfoldr) in Julia. See the reference for details about the individual functions provided by this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that when using this package, the responsibility for preventing race conditions lies with the user.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Warning: Multi-threading in Julia is an experimental feature, use with caution. Crashes may occur and are not caused by this package.","category":"page"},{"location":"reference/mapfoldl/#mapfoldl()","page":"mapfoldl()","title":"mapfoldl()","text":"","category":"section"},{"location":"reference/mapfoldl/","page":"mapfoldl()","title":"mapfoldl()","text":"tmapfoldl","category":"page"},{"location":"reference/mapfoldl/#ThreadedIterables.tmapfoldl","page":"mapfoldl()","title":"ThreadedIterables.tmapfoldl","text":"tmapfoldl(f::Function, op::Function, itr::AbstractArray)::AbstractArray\n\nMulti-threaded version of mapfoldl(f, op, itr). Only the mapping part is parallelised.\n\n\n\n\n\n","category":"function"}]
}
